#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <opus/opus.h>
#include <portaudio.h>

#define FRAME_SIZE 5760
#define MAX_PACKET_SIZE 4000
#define SAMPLE_RATE 48000
#define BUFFER_SIZE_SECONDS 30

// Global flag untuk stop playback
static volatile int stop_playback = 0;

// Struktur untuk audio stream data
typedef struct {
    short *pcm_buffer;
    int buffer_size;
    volatile int read_position;
    volatile int write_position;
    int channels;
    int bitrate;
    volatile int decoding_finished;  // Changed: Decoder selesai
    volatile int playback_finished;   // Changed: Playback selesai
} AudioData;

// Struktur Opus header (custom format)
typedef struct {
    unsigned char magic[8];
    unsigned char version;
    unsigned char channel_count;
    unsigned short pre_skip;
    unsigned int sample_rate;
    unsigned short gain;
    unsigned char channel_mapping;
} OpusHeader;

// Struktur Ogg page header
typedef struct {
    char capture_pattern[4];
    unsigned char version;
    unsigned char header_type;
    unsigned long long granule_position;
    unsigned int serial_number;
    unsigned int page_sequence;
    unsigned int checksum;
    unsigned char page_segments;
} __attribute__((packed)) OggPageHeader;

// Buffer untuk Ogg packet
typedef struct {
    unsigned char *data;
    int size;
    int capacity;
} PacketBuffer;

void packet_buffer_init(PacketBuffer *buf) {
    buf->capacity = MAX_PACKET_SIZE;
    buf->data = (unsigned char*)malloc(buf->capacity);
    buf->size = 0;
}

void packet_buffer_free(PacketBuffer *buf) {
    free(buf->data);
}

void packet_buffer_append(PacketBuffer *buf, unsigned char *data, int len) {
    if (buf->size + len > buf->capacity) {
        buf->capacity = (buf->size + len) * 2;
        buf->data = (unsigned char*)realloc(buf->data, buf->capacity);
    }
    memcpy(buf->data + buf->size, data, len);
    buf->size += len;
}

void packet_buffer_reset(PacketBuffer *buf) {
    buf->size = 0;
}

// Signal handler untuk Ctrl+C
void signal_handler(int sig) {
    printf("\n\nStopping playback...\n");
    stop_playback = 1;
}

// Callback untuk PortAudio - COMPLETELY REWRITTEN
static int audio_callback(const void *input, void *output,
                         unsigned long frameCount,
                         const PaStreamCallbackTimeInfo *timeInfo,
                         PaStreamCallbackFlags statusFlags,
                         void *userData) {
    AudioData *data = (AudioData*)userData;
    short *out = (short*)output;
    unsigned long i;
    
    (void)input;
    (void)timeInfo;
    (void)statusFlags;

    // Check for stop signal
    if (stop_playback) {
        return paComplete;
    }

    // Calculate available samples
    int available = data->write_position - data->read_position;
    
    // If no data available
    if (available <= 0) {
        // If decoding is finished and no data left, we're done
        if (data->decoding_finished) {
            data->playback_finished = 1;
            return paComplete;
        }
        // Otherwise output silence and wait for more data
        memset(out, 0, frameCount * data->channels * sizeof(short));
        return paContinue;
    }

    // Calculate how many samples we can actually play
    unsigned long samples_needed = frameCount * data->channels;
    unsigned long samples_to_play = (available < (int)samples_needed) ? available : samples_needed;
    
    // Copy audio data to output (with circular buffer support)
    for (i = 0; i < samples_to_play; i++) {
        out[i] = data->pcm_buffer[(data->read_position + i) % data->buffer_size];
    }
    
    // Update read position
    data->read_position += samples_to_play;
    
    // Fill remaining with silence if needed
    if (samples_to_play < samples_needed) {
        memset(&out[samples_to_play], 0, (samples_needed - samples_to_play) * sizeof(short));
        
        // If we couldn't fill the buffer and decoding is done, we're finishing
        if (data->decoding_finished) {
            data->playback_finished = 1;
            return paComplete;
        }
    }

    return paContinue;
}

// Fungsi untuk membaca Ogg page
int read_ogg_page(FILE *fin, OggPageHeader *header, unsigned char **packets, 
                  int *packet_sizes, int *num_packets) {
    if (fread(header, 27, 1, fin) != 1) {
        return 0;
    }

    if (memcmp(header->capture_pattern, "OggS", 4) != 0) {
        return -1;
    }

    unsigned char segments[255];
    if (fread(segments, 1, header->page_segments, fin) != header->page_segments) {
        return -1;
    }

    int payload_size = 0;
    for (int i = 0; i < header->page_segments; i++) {
        payload_size += segments[i];
    }

    unsigned char *payload = (unsigned char*)malloc(payload_size);
    if (fread(payload, 1, payload_size, fin) != payload_size) {
        free(payload);
        return -1;
    }

    *num_packets = 0;
    int pos = 0;
    PacketBuffer current_packet;
    packet_buffer_init(&current_packet);

    for (int i = 0; i < header->page_segments; i++) {
        packet_buffer_append(&current_packet, payload + pos, segments[i]);
        pos += segments[i];

        if (segments[i] < 255) {
            packets[*num_packets] = (unsigned char*)malloc(current_packet.size);
            memcpy(packets[*num_packets], current_packet.data, current_packet.size);
            packet_sizes[*num_packets] = current_packet.size;
            (*num_packets)++;
            packet_buffer_reset(&current_packet);
        }
    }

    packet_buffer_free(&current_packet);
    free(payload);
    return 1;
}

// Parse OpusHead dari Ogg
int parse_opus_head_ogg(unsigned char *packet, int size, int *sample_rate, int *channels) {
    if (size < 19 || memcmp(packet, "OpusHead", 8) != 0) {
        return 0;
    }
    *channels = packet[9];
    *sample_rate = packet[12] | (packet[13] << 8) | (packet[14] << 16) | (packet[15] << 24);
    return 1;
}

// Deteksi format file
int detect_format(const char *filename, int *is_ogg) {
    FILE *f = fopen(filename, "rb");
    if (!f) return 0;

    unsigned char magic[8];
    if (fread(magic, 1, 8, f) != 8) {
        fclose(f);
        return 0;
    }

    if (memcmp(magic, "OpusHead", 8) == 0) {
        *is_ogg = 0;
        fclose(f);
        return 1;
    } else if (memcmp(magic, "OggS", 4) == 0) {
        *is_ogg = 1;
        fclose(f);
        return 1;
    }

    fclose(f);
    return 0;
}

// Play Custom Opus format
int play_custom_opus(const char *filename) {
    FILE *fin = fopen(filename, "rb");
    if (!fin) {
        fprintf(stderr, "Error: Cannot open file '%s'\n", filename);
        return 1;
    }

    // Read header
    OpusHeader header;
    if (fread(&header, sizeof(OpusHeader), 1, fin) != 1) {
        fprintf(stderr, "Error: Failed to read Opus header\n");
        fclose(fin);
        return 1;
    }

    if (memcmp(header.magic, "OpusHead", 8) != 0) {
        fprintf(stderr, "Error: Invalid Opus header\n");
        fclose(fin);
        return 1;
    }

    int channels = header.channel_count;
    int sample_rate = header.sample_rate;

    printf("\n=== Playing Custom Opus ===\n");
    printf("Channels: %d\n", channels);
    printf("Sample Rate: %d Hz\n", sample_rate);
    printf("\nPress Ctrl+C to stop\n\n");

    // Create decoder
    int err;
    OpusDecoder *decoder = opus_decoder_create(sample_rate, channels, &err);
    if (err != OPUS_OK) {
        fprintf(stderr, "Error: Failed to create decoder: %s\n", opus_strerror(err));
        fclose(fin);
        return 1;
    }

    // Initialize PortAudio
    err = Pa_Initialize();
    if (err != paNoError) {
        fprintf(stderr, "PortAudio error: %s\n", Pa_GetErrorText(err));
        opus_decoder_destroy(decoder);
        fclose(fin);
        return 1;
    }

    // Setup audio data
    AudioData audio_data;
    audio_data.buffer_size = sample_rate * channels * BUFFER_SIZE_SECONDS;
    audio_data.pcm_buffer = (short*)calloc(audio_data.buffer_size, sizeof(short));
    audio_data.read_position = 0;
    audio_data.write_position = 0;
    audio_data.channels = channels;
    audio_data.decoding_finished = 0;
    audio_data.playback_finished = 0;

    // Open audio stream
    PaStreamParameters outputParameters;
    outputParameters.device = Pa_GetDefaultOutputDevice();
    outputParameters.channelCount = channels;
    outputParameters.sampleFormat = paInt16;
    outputParameters.suggestedLatency = Pa_GetDeviceInfo(outputParameters.device)->defaultLowOutputLatency;
    outputParameters.hostApiSpecificStreamInfo = NULL;

    PaStream *stream;
    err = Pa_OpenStream(&stream, NULL, &outputParameters, sample_rate,
                        256, paClipOff, audio_callback, &audio_data);
    
    if (err != paNoError) {
        fprintf(stderr, "PortAudio error: %s\n", Pa_GetErrorText(err));
        free(audio_data.pcm_buffer);
        Pa_Terminate();
        opus_decoder_destroy(decoder);
        fclose(fin);
        return 1;
    }

    // Start stream
    Pa_StartStream(stream);
    printf("Audio stream started\n");

    // Decode and buffer
    unsigned char *opus_data = (unsigned char*)malloc(MAX_PACKET_SIZE);
    short *pcm = (short*)malloc(FRAME_SIZE * channels * sizeof(short));
    int frame_count = 0;

    while (!stop_playback) {
        unsigned int packet_size;
        if (fread(&packet_size, sizeof(unsigned int), 1, fin) != 1) {
            break;
        }

        if (packet_size > MAX_PACKET_SIZE) break;

        if (fread(opus_data, 1, packet_size, fin) != packet_size) break;

        int num_samples = opus_decode(decoder, opus_data, packet_size, pcm, FRAME_SIZE, 0);
        if (num_samples < 0) {
            fprintf(stderr, "Decode error: %s\n", opus_strerror(num_samples));
            break;
        }

        // Wait if buffer is getting full
        while ((audio_data.write_position - audio_data.read_position) > 
               (sample_rate * channels * 5) && !stop_playback) {
            Pa_Sleep(10);
        }

        // Copy to buffer with circular buffering
        int samples_to_write = num_samples * channels;
        for (int j = 0; j < samples_to_write; j++) {
            audio_data.pcm_buffer[(audio_data.write_position + j) % audio_data.buffer_size] = pcm[j];
        }
        audio_data.write_position += samples_to_write;

        frame_count++;
        
        if (frame_count % 50 == 0) {
            float duration = (float)audio_data.write_position / (sample_rate * channels);
            int buffered = audio_data.write_position - audio_data.read_position;
            printf("\rDecoded: %.2f sec | Buffered: %.2f sec", 
                   duration, (float)buffered / (sample_rate * channels));
            fflush(stdout);
        }
    }

    // Mark decoding as finished
    audio_data.decoding_finished = 1;
    printf("\n\nDecoding finished, waiting for playback...\n");

    // Wait for playback to finish
    while (!audio_data.playback_finished && !stop_playback) {
        Pa_Sleep(100);
        int remaining = audio_data.write_position - audio_data.read_position;
        printf("\rRemaining: %.2f seconds", (float)remaining / (sample_rate * channels));
        fflush(stdout);
    }

    printf("\n✓ Playback finished\n");

    // Cleanup
    Pa_StopStream(stream);
    Pa_CloseStream(stream);
    Pa_Terminate();
    free(opus_data);
    free(pcm);
    free(audio_data.pcm_buffer);
    opus_decoder_destroy(decoder);
    fclose(fin);

    return 0;
}

// Play Ogg Opus format - COMPLETELY REWRITTEN
int play_ogg_opus(const char *filename) {
    FILE *fin = fopen(filename, "rb");
    if (!fin) {
        fprintf(stderr, "Error: Cannot open file '%s'\n", filename);
        return 1;
    }

    OggPageHeader header;
    unsigned char *packets[256];
    int packet_sizes[256];
    int num_packets;

    // Read OpusHead
    if (read_ogg_page(fin, &header, packets, packet_sizes, &num_packets) <= 0) {
        fprintf(stderr, "Error: Failed to read OpusHead page\n");
        fclose(fin);
        return 1;
    }

    int sample_rate, channels;
    
    if (!parse_opus_head_ogg(packets[0], packet_sizes[0], &sample_rate, &channels)) {
        fprintf(stderr, "Error: Invalid OpusHead\n");
        for (int i = 0; i < num_packets; i++) free(packets[i]);
        fclose(fin);
        return 1;
    }
    for (int i = 0; i < num_packets; i++) free(packets[i]);

    // Skip OpusTags
    if (read_ogg_page(fin, &header, packets, packet_sizes, &num_packets) <= 0) {
        fprintf(stderr, "Error: Failed to read OpusTags page\n");
        fclose(fin);
        return 1;
    }
    for (int i = 0; i < num_packets; i++) free(packets[i]);

    int decode_sample_rate = 48000;
    
    printf("\n=== Playing Ogg Opus ===\n");
    printf("Channels: %d\n", channels);
    printf("Original Sample Rate: %d Hz\n", sample_rate);
    printf("Decode Sample Rate: %d Hz\n", decode_sample_rate);
    printf("\nPress Ctrl+C to stop\n\n");

    // Create decoder
    int err;
    OpusDecoder *decoder = opus_decoder_create(decode_sample_rate, channels, &err);
    if (err != OPUS_OK) {
        fprintf(stderr, "Error: Failed to create decoder: %s\n", opus_strerror(err));
        fclose(fin);
        return 1;
    }

    // Initialize PortAudio
    err = Pa_Initialize();
    if (err != paNoError) {
        fprintf(stderr, "PortAudio error: %s\n", Pa_GetErrorText(err));
        opus_decoder_destroy(decoder);
        fclose(fin);
        return 1;
    }

    // Setup audio data
    AudioData audio_data;
    audio_data.buffer_size = decode_sample_rate * channels * BUFFER_SIZE_SECONDS;
    audio_data.pcm_buffer = (short*)calloc(audio_data.buffer_size, sizeof(short));
    audio_data.read_position = 0;
    audio_data.write_position = 0;
    audio_data.channels = channels;
    audio_data.decoding_finished = 0;
    audio_data.playback_finished = 0;

    // Open audio stream
    PaStreamParameters outputParameters;
    outputParameters.device = Pa_GetDefaultOutputDevice();
    
    if (outputParameters.device == paNoDevice) {
        fprintf(stderr, "Error: No default output device.\n");
        free(audio_data.pcm_buffer);
        Pa_Terminate();
        opus_decoder_destroy(decoder);
        fclose(fin);
        return 1;
    }
    
    outputParameters.channelCount = channels;
    outputParameters.sampleFormat = paInt16;
    outputParameters.suggestedLatency = Pa_GetDeviceInfo(outputParameters.device)->defaultLowOutputLatency;
    outputParameters.hostApiSpecificStreamInfo = NULL;

    printf("Using audio device: %s\n", Pa_GetDeviceInfo(outputParameters.device)->name);

    PaStream *stream;
    err = Pa_OpenStream(&stream, NULL, &outputParameters, decode_sample_rate,
                        256, paClipOff, audio_callback, &audio_data);
    
    if (err != paNoError) {
        fprintf(stderr, "PortAudio error: %s\n", Pa_GetErrorText(err));
        free(audio_data.pcm_buffer);
        Pa_Terminate();
        opus_decoder_destroy(decoder);
        fclose(fin);
        return 1;
    }

    // Start stream
    // Hasil decode opus tadi dimasukin ke stream PortAudio supaya bisa keluar ke speaker
    err = Pa_StartStream(stream);
    if (err != paNoError) {
        // kalau nilai stream adalah stderr maka akan meng stop stream, free memory, terminate Portaudio
        // destroy decoder dan close file
        // lalu return 1 buat kasi sinyal kalo program closed dengan error
        fprintf(stderr, "PortAudio start error: %s\n", Pa_GetErrorText(err));
        Pa_CloseStream(stream);
        free(audio_data.pcm_buffer);
        Pa_Terminate();
        opus_decoder_destroy(decoder);
        fclose(fin);
        return 1;
    }
    
    printf("Audio stream started\n\n");

    short *pcm = (short*)malloc(FRAME_SIZE * channels * sizeof(short));
    int frame_count = 0;

    // Decode pages
    while (!stop_playback) {
        int result = read_ogg_page(fin, &header, packets, packet_sizes, &num_packets);
        if (result == 0) break;
        if (result < 0) {
            fprintf(stderr, "Error reading Ogg page\n");
            break;
        }

        for (int i = 0; i < num_packets; i++) {
            if (packet_sizes[i] == 0) {
                free(packets[i]);
                continue;
            }

            int num_samples = opus_decode(decoder, packets[i], packet_sizes[i], 
                                         pcm, FRAME_SIZE, 0);
            
            if (num_samples > 0) {
                // Wait if buffer is getting too full (keep 5 seconds max buffered)
                while ((audio_data.write_position - audio_data.read_position) > 
                       (decode_sample_rate * channels * 5) && !stop_playback) {
                    Pa_Sleep(10);
                }
                
                // Copy to buffer with circular buffering
                int samples_to_write = num_samples * channels;
                for (int j = 0; j < samples_to_write; j++) {
                    audio_data.pcm_buffer[(audio_data.write_position + j) % audio_data.buffer_size] = pcm[j];
                }
                audio_data.write_position += samples_to_write;
                
                frame_count++;
                
                if (frame_count % 50 == 0) {
                    float decoded_duration = (float)audio_data.write_position / (decode_sample_rate * channels);
                    int buffered_samples = audio_data.write_position - audio_data.read_position;
                    float buffered_duration = (float)buffered_samples / (decode_sample_rate * channels);
                    printf("\rDecoded: %.2f sec | Buffered: %.2f sec | Playing...", 
                           decoded_duration, buffered_duration);
                    fflush(stdout);
                }
            } else if (num_samples < 0) {
                fprintf(stderr, "\nDecode error: %s\n", opus_strerror(num_samples));
            }

            free(packets[i]);
        }

        if (header.header_type & 0x04) break; // EOS
    }

    // Mark decoding as finished
    audio_data.decoding_finished = 1;
    printf("\n\nDecoding finished, waiting for playback to complete...\n");
    
    // Wait for playback to finish
    while (!audio_data.playback_finished && !stop_playback) {
        Pa_Sleep(100);
        int remaining = audio_data.write_position - audio_data.read_position;
        if (remaining > 0) {
            printf("\rRemaining: %.2f seconds", (float)remaining / (decode_sample_rate * channels));
            fflush(stdout);
        }
    }

    printf("\n✓ Playback finished\n");

    Pa_StopStream(stream);
    Pa_CloseStream(stream);
    Pa_Terminate();
    free(pcm);
    free(audio_data.pcm_buffer);
    opus_decoder_destroy(decoder);
    fclose(fin);

    return 0;
}

void print_usage(const char *prog_name) {
    printf("opusplay - Opus Audio Player\n");
    printf("=============================\n\n");
    printf("Usage:\n");
    printf("  %s <audio.opus>\n\n", prog_name);
    printf("Examples:\n");
    printf("  %s music.opus\n", prog_name);
    printf("  %s recording.opus\n\n", prog_name);
    printf("Supported formats:\n");
    printf("  ✓ Ogg Opus (universal format)\n");
    printf("  ✓ Custom Raw Opus (from eopus)\n\n");
    printf("Controls:\n");
    printf("  Ctrl+C : Stop playback\n");
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        print_usage(argv[0]);
        return 1;
    }

    const char *filename = argv[1];

    // Setup signal handler
    signal(SIGINT, signal_handler);

    // Detect format
    int is_ogg;
    if (!detect_format(filename, &is_ogg)) {
        fprintf(stderr, "Error: Unable to detect file format or file not found\n");
        return 1;
    }

    // Play based on format
    if (is_ogg) {
        return play_ogg_opus(filename);
    } else {
        return play_custom_opus(filename);
    }
}